<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Design and Analysis of Algorithms - Learning Portfolio</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>

    <header>
        <h1>Design and Analysis of Algorithms</h1>
        <h2>Learning Portfolio</h2>
    </header>

    <!-- Student Information -->
    <section>
        <h3>Student Information</h3>
        <ul>
            <li><strong>Name:</strong> Varun S Terdal</li>
            <li><strong>SRN:</strong> 01FE23BCI068</li>
            <li><strong>Course Name:</strong> Design And Analysis Of Algorithms</li>
            <li><strong>University:</strong> KLE Technological University</li>
            <li><strong>Portfolio Topic/Domain:</strong> DAA Course Project</li>
        </ul>
    </section>

    <!-- Course Introduction -->
    <section>
        <h3>Course Introduction</h3>
        <p>
            The "Design and Analysis of Algorithms" (DAA) course develops the ability to create efficient algorithms to solve
            computational problems. It focuses on understanding <strong>how algorithms work</strong>, how to measure their
            efficiency, and how to design them for various problem types.
        </p>
        <p>
            Key concepts include:
        </p>
        <ul>
            <li>Time complexity and space complexity (Big O, Big Θ, Big Ω)</li>
            <li>Algorithm design paradigms: Divide-and-Conquer, Greedy, Dynamic Programming, Backtracking</li>
            <li>Graph and network algorithms</li>
            <li>Optimization problems (Knapsack, TSP)</li>
            <li>Theoretical foundations like NP-completeness and undecidability</li>
        </ul>
    </section>

    <!-- Data Structures -->
    <section>
        <h3>Data Structures</h3>

        <h4>Basic Structures</h4>
        <p>
            <strong>Arrays:</strong> Fixed-size collections, fast access using indices. Example: storing student marks.
        </p>
        <p>
            <strong>Stacks:</strong> LIFO structure, supports push/pop operations. Example: Undo operations in text editors.
        </p>
        <p>
            <strong>Queues:</strong> FIFO structure, used in scheduling and buffering. Example: Print queue.
        </p>
        <p>
            <strong>Linked Lists:</strong> Dynamic memory allocation, easy insertion/deletion. Types: singly, doubly, circular.
        </p>

        <h4>Intermediate Structures</h4>
        <p>
            <strong>Trees:</strong> Hierarchical structure, useful for searching and sorting. Example: Binary Search Tree (BST)
        </p>
        <p>
            <strong>Graphs:</strong> Represent networks. Types: Directed, Undirected, Weighted, Unweighted.
        </p>
        <p>
            <strong>Heaps:</strong> Complete binary tree for priority queues. Example: Min Heap for minimum extraction.
        </p>

        <h4>Advanced Structures</h4>
        <p>
            <strong>Tries:</strong> Efficient string storage for prefix search. Example: Auto-complete in search engines.
        </p>
        <p>
            <strong>Fenwick Trees / BIT:</strong> Range queries in O(log n) time.
        </p>
        <p>
            <strong>Segment Trees:</strong> Range queries and updates, useful for interval problems.
        </p>
        <p>
            <strong>Skip Lists:</strong> Probabilistic data structure for fast insertion/search in sorted lists.
        </p>
    </section>

    <!-- Algorithms -->
    <section>
        <h3>Algorithms</h3>

        <h4>Sorting & Searching</h4>
        <p>
            <strong>Bubble Sort:</strong> Repeatedly swap adjacent elements. Complexity: O(n²)
        </p>
        <p><strong>Pseudocode:</strong></p>
        <pre>
for i = 0 to n-1:
    for j = 0 to n-i-1:
        if arr[j] > arr[j+1]:
            swap(arr[j], arr[j+1])
        </pre>
        <p>
            <strong>Merge Sort:</strong> Divide-and-conquer algorithm, complexity: O(n log n)
        </p>
        <pre>
function mergeSort(arr):
    if length(arr) <= 1:
        return arr
    mid = length(arr)/2
    left = mergeSort(arr[0:mid])
    right = mergeSort(arr[mid:])
    return merge(left, right)
        </pre>

        <h4>Graph Algorithms</h4>
        <ul>
            <li>Dijkstra's algorithm: Shortest path in weighted graph (no negative weights)</li>
            <li>Bellman-Ford algorithm: Shortest path (supports negative weights)</li>
            <li>Prim & Kruskal: Minimum Spanning Tree (MST)</li>
            <li>Floyd-Warshall: All pairs shortest path</li>
        </ul>

        <h4>Dynamic Programming</h4>
        <p>
            Solve complex problems by breaking into smaller overlapping subproblems and storing results.
            Example: Fibonacci, Longest Common Subsequence, 0/1 Knapsack.
        </p>

        <h4>Recursion & Backtracking</h4>
        <p>
            Solve problems incrementally and backtrack if constraints fail. Example: N-Queens, Sudoku solver.
        </p>

        <h4>String Matching</h4>
        <p>
            Naive, KMP, Rabin-Karp, Boyer-Moore algorithms for pattern search in strings. Important in search engines.
        </p>

        <h4>Optimization Problems</h4>
        <p>
            Knapsack, Traveling Salesperson Problem (TSP), Huffman Coding. Applied in resource allocation, logistics, and compression.
        </p>

        <h4>Undecidability & Complexity</h4>
        <p>
            Halting Problem, P vs NP, NP-Complete problems. Understand the limits of computation.
        </p>
    </section>

    <!-- Applications -->
    <section>
        <h3>Real-Time Applications</h3>
        <ul>
            <li>Graph algorithms: GPS routing, network design, social networks</li>
            <li>Sorting & Searching: Databases, e-commerce search, analytics</li>
            <li>Dynamic Programming: Resource optimization, scheduling tasks</li>
            <li>Data Structures: Memory management, database indexing, cache systems</li>
        </ul>
    </section>

    <!-- Project -->
    <section>
        <h3>Course Project</h3>
        <p>
            The project focuses on optimizing traffic flow, route planning, and resource allocation in smart cities.
        </p>
        <h4>Problem Definition & Team Details</h4>
        <ul>
            <li>Optimizing traffic lights, emergency routing, and resource allocation.</li>
            <li>Team Members collaborated on subproblems like traffic flow, emergency services, and business logistics.</li>
        </ul>
    </section>

    <!-- Reflections -->
    <section>
        <h3>Course Learning Reflections</h3>
        <p>
            Sorting, searching, and pathfinding are fundamental problem types. Recursion, backtracking, greedy, and dynamic
            programming offer powerful methods to solve them efficiently.
        </p>
        <p>
            Understanding <strong>time complexity</strong> (speed) and <strong>space complexity</strong> (memory usage) is
            essential. Orders of growth (O(1), O(log n), O(n), O(n log n), O(n²)) help classify algorithms and choose
            the best approach.
        </p>
    </section>

    <footer>
        <p>&copy; 2025 Design and Analysis of Algorithms - Learning Portfolio - Varun</p>
    </footer>

</body>
</html>
